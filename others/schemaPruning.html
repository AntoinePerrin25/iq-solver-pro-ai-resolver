<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Concepts de r&eacute;solution en Intelligence Artificielle</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h3 id="concepts-de-résolution-en-intelligence-artificielle">Concepts de résolution en Intelligence Artificielle</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Stratégies d'optimisation utilisées</p>
        <table border="1">
            <tr><th>Technique IA</th><th>Application au puzzle</th><th>Impact</th></tr>
            <tr bgcolor="#FFE4E1">
                <td>Heuristique MRV</td>
                <td>Sélection des choix les plus contraints</td>
                <td>↓ 70% branches explorées</td>
            </tr>
            <tr bgcolor="#E0FFFF">
                <td>Forward Checking</td>
                <td>Détection précoce impasses</td>
                <td>↓ 40% temps calcul</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Dynamic Ordering</td>
                <td>Priorité pièces grandes</td>
                <td>↓ 50% backtracking</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>2. Complexité et Performance</p>
        <table border="1">
            <tr><th>Métrique</th><th>Brute Force</th><th>Notre Solution</th></tr>
            <tr>
                <td>Complexité</td>
                <td>O(n! × 8ⁿ)</td>
                <td>O(b^d) avec pruning</td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>Temps moyen</td>
                <td>>1 heure</td>
                <td><100ms</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Mémoire</td>
                <td>O(n²)</td>
                <td>O(n)</td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>3. Intelligence du système</p>
        <table border="1">
            <tr><th>Capacité</th><th>Méthode</th></tr>
            <tr>
                <td>Apprentissage</td>
                <td>Cache des zones valides</td>
            </tr>
            <tr bgcolor="#E0FFFF">
                <td>Adaptation</td>
                <td>Heuristiques dynamiques</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Optimisation</td>
                <td>Pruning intelligent</td>
            </tr>
        </table>
    </div>
</div>
<p><em>Points clés pour le jury :</em></p>
<ol>
<li>Intelligence du système démontrée par :
<ul>
<li>Apprentissage des configurations impossibles</li>
<li>Adaptation des stratégies selon le contexte</li>
<li>Optimisation continue des performances</li>
</ul>
</li>
<li>Résultats prouvés :
<ul>
<li>Résolution en temps réel (&lt;100ms)</li>
<li>Scaling sur grandes grilles</li>
<li>Robustesse aux cas complexes</li>
</ul>
</li>
</ol>
<h3 id="concepts-fondamentaux-pour-iq-solver-pro">Concepts fondamentaux pour IQ Solver Pro</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Définitions de base</p>
        <table border="1">
            <tr><th>Concept</th><th>Définition</th><th>Exemple dans notre jeu</th></tr>
            <tr>
                <td>SAT</td>
                <td>Problème qui cherche à rendre vraie une formule logique</td>
                <td>"Cette pièce peut-elle être placée ici?"</td>
            </tr>
            <tr>
                <td>CSP</td>
                <td>Problème avec variables devant respecter des contraintes</td>
                <td>Placement des 12 pièces sans chevauchement</td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>Variables</td>
                <td>Éléments à assigner</td>
                <td>Position et rotation de chaque pièce</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>2. Notre problème comme CSP</p>
        <table border="1">
            <tr><th>Élément</th><th>Description</th><th>Exemple</th></tr>
            <tr>
                <td>Variables</td>
                <td>12 pièces à placer</td>
                <td>Pièce rouge = (x,y,r)</td>
            </tr>
            <tr>
                <td>Domaine</td>
                <td>Positions et rotations valides</td>
                <td>(0≤x≤11, 0≤y≤5, 0≤r≤8)</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Contraintes</td>
                <td>Règles à respecter</td>
                <td>• Pas de superposition<br/>• Grille remplie<br/>• 1 fois chaque pièce</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Exemple concret</p>
        <table border="1">
            <tr>
                <td>État initial</td>
                <td>
                    Grille vide 5×11<br/>
                    12 pièces disponibles<br/>
                    Chaque pièce: plusieurs rotations
                </td>
            </tr>
            <tr>
                <td>Contrainte SAT</td>
                <td>
                    Pour position (2,3):<br/>
                    "Une et une seule pièce ici"
                </td>
            </tr>
            <tr bgcolor="#E0FFFF">
                <td>Solution CSP</td>
                <td>
                    Pièce1 = (0,0,0)<br/>
                    Pièce2 = (1,2,90°)<br/>
                    ...etc
                </td>
            </tr>
        </table>
    </div>
</div>
<p><em>Points clés :</em></p>
<ol>
<li>SAT = Problème de décision (vrai/faux)</li>
<li>CSP = Problème d'assignation de valeurs</li>
<li>Notre puzzle combine les deux :
<ul>
<li>SAT : &quot;Est-ce qu'on peut placer ici?&quot;</li>
<li>CSP : &quot;Où placer chaque pièce?&quot;</li>
</ul>
</li>
</ol>
<h3 id="de-sat-à-csp---explications-fondamentales">De SAT à CSP - Explications fondamentales</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. SAT (Problème de satisfiabilité)</p>
        <table border="1">
            <tr><th>Concept</th><th>Exemple simple</th></tr>
            <tr>
                <td>Variables booléennes<br/>(vrai/faux)</td>
                <td>
                    x = "Il pleut"<br/>
                    y = "Je prends mon parapluie"
                </td>
            </tr>
            <tr>
                <td>Formule à satisfaire</td>
                <td>
                    "S'il pleut, je prends mon parapluie"<br/>
                    = (x → y)
                </td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>Solution</td>
                <td>
                    x = vrai, y = vrai ✓<br/>
                    x = faux, y = vrai ✓<br/>
                    x = faux, y = faux ✓<br/>
                    x = vrai, y = faux ✗
                </td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>2. CSP (Problème de satisfaction de contraintes)</p>
        <table border="1">
            <tr><th>Concept</th><th>Exemple: Sudoku</th></tr>
            <tr>
                <td>Variables</td>
                <td>Cases à remplir</td>
            </tr>
            <tr>
                <td>Domaine</td>
                <td>Chiffres de 1 à 9</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Contraintes</td>
                <td>
                    • Une fois par ligne<br/>
                    • Une fois par colonne<br/>
                    • Une fois par bloc
                </td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Notre puzzle = CSP</p>
        <table border="1">
            <tr><th>Élément</th><th>Dans notre jeu</th></tr>
            <tr>
                <td>Variables</td>
                <td>Les 12 pièces à placer</td>
            </tr>
            <tr>
                <td>Domaine</td>
                <td>Positions possibles sur la grille</td>
            </tr>
            <tr bgcolor="#E0FFFF">
                <td>Contraintes</td>
                <td>
                    • Pas de chevauchement<br/>
                    • Tout doit être couvert<br/>
                    • Chaque pièce utilisée une fois
                </td>
            </tr>
        </table>
    </div>
</div>
<p><em>En résumé :</em></p>
<ol>
<li>SAT : Trouver valeurs vrai/faux qui rendent une formule vraie</li>
<li>CSP : Trouver valeurs respectant des contraintes</li>
<li>Notre puzzle : Un CSP où on cherche les positions des pièces</li>
<li></li>
<li>
<h3 id="sat-et-réduction-vers-csp">SAT et Réduction vers CSP</h3>
</li>
</ol>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Le problème SAT</p>
        <table border="1">
            <tr><th>Définition formelle</th><th>Exemple</th></tr>
            <tr>
                <td>
                    Soit F une formule booléenne :<br/>
                    F = C₁ ∧ C₂ ∧ ... ∧ Cₙ<br/>
                    où Cᵢ = (lᵢ₁ ∨ lᵢ₂ ∨ lᵢ₃)<br/>
                    lᵢⱼ ∈ {x, ¬x}
                </td>
                <td>
                    F = (x₁ ∨ ¬x₂ ∨ x₃) ∧<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;(¬x₁ ∨ x₂ ∨ x₄) ∧<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;(x₂ ∨ ¬x₃ ∨ x₄)
                </td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>2. Réduction vers notre CSP</p>
        <table border="1">
            <tr><th>SAT</th><th>IQ Puzzler</th></tr>
            <tr>
                <td>Variable xᵢ</td>
                <td>Pièce pᵢ à position (x,y)</td>
            </tr>
            <tr>
                <td>(x₁ ∨ x₂ ∨ x₃)</td>
                <td>∃(x,y) | pᵢ(x,y) = 1</td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>∧ (conjonction)</td>
                <td>Toutes contraintes respectées</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Équivalence formelle</p>
        <table border="1">
            <tr><th>Propriété</th><th>Expression mathématique</th></tr>
            <tr>
                <td>Non-chevauchement</td>
                <td>∀i,j, pᵢ ∩ pⱼ = ∅</td>
            </tr>
            <tr>
                <td>Couverture</td>
                <td>⋃ᵢ pᵢ = Plateau</td>
            </tr>
            <tr>
                <td>Unicité</td>
                <td>∀i, ∃!(x,y) | pᵢ(x,y) = 1</td>
            </tr>
        </table>
    </div>
</div>
<p><em>Théorème :</em></p>
<ul>
<li>Soit Π notre problème</li>
<li>∀F∈3-SAT, ∃τ:F→Π en temps polynomial</li>
<li>F satisfiable ⟺ τ(F) a une solution</li>
<li></li>
<li>
<h3 id="définition-formelle-dun-csp">Définition formelle d'un CSP</h3>
</li>
</ul>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Composants fondamentaux</p>
        <table border="1">
            <tr><th>Élément</th><th>Définition</th><th>Notre cas</th></tr>
            <tr>
                <td>Variables (X)</td>
                <td>Ensemble fini de variables</td>
                <td>X = {pièce₁, pièce₂, ..., pièce₁₂}</td>
            </tr>
            <tr>
                <td>Domaines (D)</td>
                <td>Valeurs possibles pour chaque variable</td>
                <td>D = {positions × rotations possibles}</td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>Contraintes (C)</td>
                <td>Relations entre variables</td>
                <td>C = {non-chevauchement, couverture}</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>2. Réduction 3-SAT → IQ Puzzler</p>
        <table border="1">
            <tr><th>3-SAT</th><th>Notre problème</th></tr>
            <tr>
                <td>Variables booléennes</td>
                <td>Position pièce (placée/non-placée)</td>
            </tr>
            <tr>
                <td>Clauses</td>
                <td>Contraintes de placement</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>(x₁ ∨ x₂ ∨ x₃)</td>
                <td>"Une des 3 positions doit être utilisée"</td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>3. Preuve NP-complétude</p>
        <table border="1">
            <tr><th>Étape</th><th>Démonstration</th></tr>
            <tr>
                <td>NP</td>
                <td>Solution vérifiable en O(n)</td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>NP-dur</td>
                <td>3-SAT réductible à notre problème</td>
            </tr>
        </table>
    </div>
</div>
<p><em>Points clés pour le jury :</em></p>
<ol>
<li>Un CSP est défini par le triplet (X,D,C)</li>
<li>NP-complet car :
<ul>
<li>Une solution est vérifiable en temps polynomial</li>
<li>On peut réduire 3-SAT vers notre problème</li>
</ul>
</li>
<li>La réduction montre que si on peut résoudre notre puzzle, on peut résoudre n'importe quel 3-SAT</li>
</ol>
<h3 id="le-iq-puzzler-pro-comme-problème-de-satisfaction-de-contraintes-csp">Le IQ Puzzler Pro comme problème de satisfaction de contraintes (CSP)</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Définition formelle</p>
        <table border="1">
            <tr><th>Composant</th><th>Dans notre contexte</th></tr>
            <tr>
                <td>Variables (X)</td>
                <td>Positions possibles des pièces</td>
            </tr>
            <tr>
                <td>Domaines (D)</td>
                <td>Variantes × positions valides</td>
            </tr>
            <tr bgcolor="#FFE4E1">
                <td>Contraintes (C)</td>
                <td>
                    • Non-chevauchement<br/>
                    • Utilisation unique<br/>
                    • Couverture complète
                </td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>2. Caractéristiques NP-complètes</p>
        <table border="1">
            <tr><th>Facteur</th><th>Impact</th></tr>
            <tr>
                <td>Taille domaine</td>
                <td>O(positions × rotations)</td>
            </tr>
            <tr>
                <td>Branchement</td>
                <td>O(n!) pour n pièces</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Réduction</td>
                <td>3-SAT → Notre problème</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Techniques de résolution CSP</p>
        <table border="1">
            <tr><th>Technique</th><th>Application</th></tr>
            <tr>
                <td>Forward checking</td>
                <td>Détection zones impossibles</td>
            </tr>
            <tr>
                <td>MRV (Minimum Remaining Values)</td>
                <td>Choix colonne contraignante</td>
            </tr>
            <tr>
                <td>Backtracking intelligent</td>
                <td>Retour optimisé après échec</td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>4. Optimisations CSP spécifiques</p>
        <table border="1">
            <tr><th>Méthode</th><th>Gain</th></tr>
            <tr>
                <td>Propagation contraintes</td>
                <td>Réduction branches</td>
            </tr>
            <tr>
                <td>Heuristiques statiques</td>
                <td>Ordre pièces optimal</td>
            </tr>
            <tr>
                <td>Cache contraintes</td>
                <td>Évite recalculs</td>
            </tr>
        </table>
    </div>
</div>
<p><em>Aspects théoriques :</em></p>
<ol>
<li>La NP-complétude prouvée par réduction polynomiale</li>
<li>Espace de recherche : O(P! × R^P) où :
<ul>
<li>P = nombre de pièces</li>
<li>R = nombre de rotations possibles</li>
</ul>
</li>
<li>Techniques de réduction :
<ul>
<li>Propagation de contraintes</li>
<li>Élagage précoce</li>
<li>Heuristiques informées</li>
</ul>
</li>
</ol>
<p>Limites et Perspectives</p>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;"> <div> <p>1. Limitations actuelles</p> <table border="1"> <tr bgcolor="#FFE4E1"> <td>Performance</td> <td>• Explosion combinatoire<br/>• Mono-thread</td> </tr> <tr bgcolor="#FFE4E1"> <td>Génération</td> <td>• Formes complexes<br/>• Doublons</td> </tr> </table> </div> → <div> <p>2. Pistes d'amélioration</p> <table border="1"> <tr bgcolor="#90EE90"> <td>Code</td> <td>Migration C++<br/>Multi-threading</td> </tr> <tr bgcolor="#90EE90"> <td>Algo</td> <td>Liens dansants<br/>Optimisation générateur</td> </tr> </table> </div> </div>
Objectifs atteints :
<p>✓ Résolution 5×11
✓ Optimisations efficaces</p>
<h3 id="états-et-conditions-pour-lalgorithme-x">États et conditions pour l'algorithme X</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>4. Solution valide si</p>
        <table border="1">
            <tr>
                <th>Condition</th>
                <th>Exemple</th>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Plus de cases vides</td>
                <td>Aucun -1 dans la grille</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Chaque pièce utilisée une fois</td>
                <td>
                    0 0 1<br/>
                    1 1 2<br/>
                    (0,1,2 présents une fois)
                </td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Positions cohérentes</td>
                <td>
                    Si grille montre "0" aux coords (x,y)<br/>
                    → La pièce 0 doit être à (x,y)
                </td>
            </tr>
        </table>
    </div>
</div>
<h3 id="états-initiaux-pour-lancer-lalgorithme-x">États initiaux pour lancer l'algorithme X</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;"> <div> <p>1. État du plateau</p> <table border="1"> <tr> <td>Matrice 5×11</td> <td> <table> <tr><td>-1</td><td>0</td><td>0</td><td>1</td></tr> <tr><td>-1</td><td>0</td><td>1</td><td>1</td></tr> <tr bgcolor="#FFE4E1"><td colspan="4">S = {-1, 0, ..., N}</td></tr> </table> </td> </tr> </table> </div> → <div> <p>2. État pièces</p> <table border="1"> <tr> <td>Matrice 4×4</td> <td> <table> <tr><td>1</td><td>1</td><td>0</td><td>0</td></tr> <tr><td>1</td><td>0</td><td>0</td><td>0</td></tr> <tr bgcolor="#E0FFFF"><td colspan="4">P = {0, ..., n}</td></tr> </table> </td> </tr> </table> </div> </div> <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;"> <div> <p>3. Suivi pièces placées</p> <table border="1"> <tr> <td>Dict[str, Info]</td> <td> {<br/> &nbsp;&nbsp;"rouge": {pos:(0,0), var:2},<br/> &nbsp;&nbsp;"bleu": {pos:(1,0), var:1}<br/> } </td> </tr> </table> </div> → <div> <p>4. Solution valide si</p> <table border="1"> <tr bgcolor="#90EE90"><td>∄ case = -1</td></tr> <tr bgcolor="#90EE90"><td>∀ i ∈ [0,N] présent une fois</td></tr> <tr bgcolor="#90EE90"><td>Chaque i = position pièce i</td></tr> </table> </div> </div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. État du plateau (Matrice numpy)</p>
        <table border="1">
            <tr><th>Plateau 5×11</th><th>Signification</th></tr>
            <tr>
                <td>
                    -1 -1 -1 -1 -1<br/>
                    -1 -1 -1 -1 -1<br/>
                    -1 -1 -1 -1 -1<br/>
                </td>
                <td>
                    -1 = Case vide<br/>
                    0-N = Index pièce placée<br/>
                </td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>2. Représentation des pièces</p>
        <table border="1"> 
            <tr><th>Pièce "rouge"</th><th>Forme base</th><th>Variantes</th></tr>
            <tr>
                <td>
                    Matrice 4×4<br/>
                    1 1 1 1<br/>
                    0 0 0 1<br/>
                    0 0 0 0<br/>
                    0 0 0 0<br/>
                </td>
                <td>
                    ████<br/>
                    &nbsp;&nbsp;&nbsp;█
                </td>
                <td>
                    8 rotations possibles<br/>
                    (90°, 180°, 270°<br/>
                    + symétries)
                </td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Suivi des pièces</p>
        <table border="1">
            <tr><th>Dict placed_pieces</th><th>Dict pieces</th></tr>
            <tr>
                <td>
                    "rouge": {<br/>
                    &nbsp;&nbsp;position: (0,0)<br/>
                    &nbsp;&nbsp;variante: 2<br/>
                    &nbsp;&nbsp;cells: [(0,0),(0,1)]<br/>
                    }
                </td>
                <td>
                    "rouge": Piece()<br/>
                    "bleu": Piece()<br/>
                    ...<br/>
                    Toutes les pièces disponibles
                </td>
            </tr>
        </table>
    </div>
    →
    <div>
        <p>4. État validation</p>
        <table border="1">
            <tr><th>Condition</th><th>Check</th></tr>
            <tr><td>Toutes cases remplies</td><td>Plus de -1</td></tr>
            <tr><td>Pas de chevauchement</td><td>Indices uniques</td></tr>
            <tr><td>Toutes pièces utilisées</td><td>placed_pieces complet</td></tr>
        </table>
    </div>
</div>
<p><em>Informations clés :</em></p>
<ol>
<li>Plateau = matrice numpy (-1 = vide)</li>
<li>Pièces = matrices 4×4 (1 = occupé)</li>
<li>Suivi via dictionnaires:
<ul>
<li>placed_pieces: pièces placées + positions</li>
<li>pieces: toutes les pièces disponibles</li>
</ul>
</li>
<li>Validation vérifie 3 conditions</li>
</ol>
<h3 id="notre-implémentation-vs-liens-dansants">Notre implémentation VS Liens dansants</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Notre code actuel (ConstraintMatrixBuilder)</p>
        <table border="1">
            <tr bgcolor="#FFB6C1"><td>Structure</td><td>Liste de dictionnaires</td></tr>
            <tr><td>Suppression</td><td>Création nouvelle liste filtrée</td></tr>
            <tr><td>Restauration</td><td>Via solution.pop()</td></tr>
            <tr><td>Complexité</td><td>O(n) pour suppression/restauration</td></tr>
        </table>
    </div>
    →
    <div>
        <p>2. Version liens dansants (non implémentée)</p>
        <pre>
class DancingNode:
    def __init__(self):
        self.left = self
        self.right = self
        self.up = self
        self.down = self
        self.column = None
        </pre>
        <p>✓ O(1) pour suppression/restauration</p>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Impact sur performances</p>
        <table border="1">
            <tr><th>Notre code</th><th>Avec liens dansants</th></tr>
            <tr bgcolor="#FFB6C1">
                <td>
                    new_matrix = []<br/>
                    for r in matrix:<br/>
                    &nbsp;&nbsp;if conditions:<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;new_matrix.append(r)
                </td>
                <td>
                    node.right.left = node.left<br/>
                    node.left.right = node.right
                </td>
            </tr>
        </table>
    </div>
</div>
<p><em>Amélioration possible :</em></p>
<ul>
<li>Remplacer notre structure actuelle par des liens dansants</li>
<li>Gagner en performance sur les grandes grilles</li>
<li>Réduire utilisation mémoire</li>
</ul>
<h3 id="liens-dansants-vs-matrice-de-contraintes-classique">Liens dansants VS Matrice de contraintes classique</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Matrice classique</p>
        <table border="1">
            <tr><th>Pos</th><th>C1</th><th>C2</th><th>C3</th></tr>
            <tr><td>A1</td><td>1</td><td>0</td><td>1</td></tr>
            <tr><td>A2</td><td>0</td><td>1</td><td>1</td></tr>
        </table>
        <p>❌ Suppression = O(n²)</p>
    </div>
    →
    <div>
        <p>2. Structure liens dansants</p>
        <pre>
Head → C1 ⟷ C2 ⟷ C3
 ↕     ↕     ↕     ↕ 
A1  →  1  ⟷  0  ⟷  1
 ↕     ↕           ↕
A2  →  0  ⟷  1  ⟷  1
        </pre>
        <p>✓ Suppression = O(1)</p>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Opération de suppression</p>
        <table border="1">
            <tr><th>Étape</th><th>Action</th></tr>
            <tr><td>Classique</td><td>Recopie toute la matrice sans la ligne/colonne</td></tr>
            <tr bgcolor="#90EE90"><td>Liens dansants</td><td>Modifie juste les pointeurs ⟷</td></tr>
        </table>
    </div>
    →
    <div>
        <p>4. Restauration</p>
        <table border="1">
            <tr><th>Étape</th><th>Action</th></tr>
            <tr><td>Classique</td><td>Recopie depuis sauvegarde</td></tr>
            <tr bgcolor="#90EE90"><td>Liens dansants</td><td>Remet les pointeurs d'origine</td></tr>
        </table>
    </div>
</div>
<p><em>Avantages liens dansants :</em></p>
<ol>
<li>Suppression/restauration instantanée O(1)</li>
<li>Pas besoin de copier la matrice</li>
<li>Navigation rapide entre éléments liés</li>
<li>Parfait pour backtracking intensif</li>
</ol>
<h3 id="problème-np-complet-et-liens-dansants">Problème NP-complet et liens dansants</h3>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Pourquoi NP-complet ?</p>
        <table border="1">
            <tr><th>Pour une grille N×M</th></tr>
            <tr><td>• Chaque case : 2 états (vide/occupée)</td></tr>
            <tr><td>• P pièces avec R rotations chacune</td></tr>
            <tr bgcolor="#FFB6C1"><td>→ O(P! × R^P) combinaisons possibles</td></tr>
            <tr><td>Ex: 12 pièces, 8 rotations = 12! × 8¹² solutions</td></tr>
        </table>
    </div>
    →
    <div>
        <p>2. Liens dansants : structure de données</p>
        <table border="1">
            <tr>
                <td>
                    <pre>
Header → C1 ⇄ C2 ⇄ C3
  ↕      ↕    ↕    ↕
 L1.1    1    0    1
  ↕      ↕         ↕
 L2.1    0    1    1
                    </pre>
                </td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Permet suppression/restauration O(1)</td>
            </tr>
        </table>
    </div>
</div>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>3. Pourquoi le backtracking ?</p>
        <table border="1">
            <tr><th>Méthode</th><th>Avantage</th></tr>
            <tr bgcolor="#E0FFFF">
                <td>Force brute</td>
                <td>❌ Explosion combinatoire</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Backtracking + MRV</td>
                <td>✓ Élagage rapide branches impossibles</td>
            </tr>
            <tr bgcolor="#90EE90">
                <td>Liens dansants</td>
                <td>✓ Opérations rapides O(1)</td>
            </tr>
        </table>
    </div>
</div>
<p><em>Explication :</em></p>
<ol>
<li>NP-complet car nombre de solutions croît factoriellement</li>
<li>Liens dansants = liste doublement chaînée permettant:
<ul>
<li>Suppression/restauration rapide O(1)</li>
<li>Navigation efficace dans la matrice</li>
</ul>
</li>
<li>Backtracking optimal car:
<ul>
<li>Détection rapide impasses</li>
<li>Peu de mémoire utilisée</li>
<li>Combine bien avec heuristiques (MRV)</li>
</ul>
</li>
</ol>
<p><strong>Détection des zones Z1 par BFS</strong></p>
<p><strong>Propagation complète de Z1</strong></p>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. Départ Z1 (1,0)</p>
        <table>
            <tr><td> </td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
            <tr><td>0</td><td>A</td><td>A</td><td>B</td><td>B</td></tr>
            <tr><td>1</td><td>Z1</td><td>-1</td><td>B</td><td>-1</td></tr>
            <tr><td>2</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr>
        </table>
    </div>
    →
    <div>
        <p>2. BFS Z1 : étape 1</p>
        <table>
            <tr><td> </td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
            <tr><td>0</td><td>A</td><td>A</td><td>B</td><td>B</td></tr>
            <tr><td>1</td><td>Z1</td><td>Z1</td><td>B</td><td>-1</td></tr>
            <tr><td>2</td><td>Z1</td><td>Z1</td><td>Z1</td><td>-1</td></tr>
        </table>
    </div>
    →
    <div>
        <p>3. BFS Z1 : final</p>
        <table>
            <tr><td> </td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
            <tr><td>0</td><td>A</td><td>A</td><td>B</td><td>B</td></tr>
            <tr><td>1</td><td>Z1</td><td>Z1</td><td>B</td><td>Z1</td></tr>
            <tr><td>2</td><td>Z1</td><td>Z1</td><td>Z1</td><td>Z1</td></tr>
        </table>
    </div>
</div>
<p><em>Règle de propagation :</em></p>
<ul>
<li>Une zone continue de s'étendre tant qu'elle trouve des cases vides (-1) adjacentes</li>
<li>Le BFS explore toutes les directions (→,↓,←,↑) pour chaque case</li>
<li>Il n'y a qu'une seule zone Z1 car toutes les cases vides sont connectées</li>
</ul>
<p><em>Processus :</em></p>
<ol>
<li>Parcours la grille jusqu'à trouver une case vide (-1)</li>
<li>Lance un BFS depuis cette case</li>
<li>Marque toutes les cases vides adjacentes connectées</li>
<li>Répète pour les cases vides non marquées restantes</li>
</ol>
<p><strong>Exemple de détection des zones impossibles</strong></p>
<div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8em;">
    <div>
        <p>1. État initial</p>
        <table>
            <tr><td> </td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
            <tr><td>0</td><td>A</td><td>A</td><td>B</td><td>B</td></tr>
            <tr><td>1</td><td>C</td><td>-1</td><td>B</td><td>-1</td></tr>
            <tr><td>2</td><td>C</td><td>C</td><td>-1</td><td>-1</td></tr>
        </table>
    </div>
    →
    <div>
        <p>2. Détection zones</p>
        <table>
            <tr><td> </td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
            <tr><td>0</td><td>A</td><td>A</td><td>B</td><td>B</td></tr>
            <tr><td>1</td><td>C</td><td>Z1</td><td>B</td><td>Z2</td></tr>
            <tr><td>2</td><td>C</td><td>C</td><td>Z2</td><td>Z2</td></tr>
        </table>
    </div>
    →
    <div>
        <p>3. Analyse zones</p>
        <table>
            <tr><td>Zone</td><td>Taille</td><td>Pièces restantes</td><td>Possible?</td></tr>
            <tr><td>Z1</td><td>3</td><td>4</td><td>❌</td></tr>
            <tr><td>Z1</td><td>1</td><td>4</td><td>❌</td></tr>
        </table>
    </div>
</div>
<p><em>Explication :</em></p>
<ul>
<li>Zone Z1 : 4 cases mais somme impossible avec pièces restantes (3+2≠4)</li>
<li>Zone Z2 : 3 cases, peut être remplie par une pièce de taille 3</li>
<li>→ La branche est coupée car Z1 est impossible à remplir</li>
</ul>

            
            
        </body>
        </html>